matrix(c(1,2,3,4),ncol=2)
matrix(c(1,2,3,4),c(5,6,7,8),ncol=2)
matrix(c(c(1,2,3,4),c(5,6,7,8)),ncol=2)
set1 <-matrix(c(c(1,2,3,4),c(5,6,7,8)),ncol=2)
set2 <-matrix(c(c(6),c(8)),ncol=2)
set2
rownames(set1) <- letters()[1:4]
rownames(set1) <- letter()[1:4]
rownames(set1) <- letters[1:4]
set1
over <-interval_overlap(set1,set2)
library(intervals)
install.packages("intervals")
install.packages("intervals")
library(intervals)
set1 <- Intervals(set1)
set2 <- Intervals(set2)
over <-interval_overlap(set1,set2)
over
set2
set1
names(unlist(over[over!=0]))
testmat <- list(matrix(rep(0,100),nrow=10),"1")
for(i in 1:10){testmat[[1]][i,i] <- 1}
for(i in 5:7){testmat[[1]][4,i]<-1}
for(i in 6:7){testmat[[1]][5,i]<-1}
testmat[[1]][6,7]<-1
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R+1,(length(M[1,])-(D/R))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
return(diam)
}
diam_slide(testmat)
diam_slide(testmat[[1]])
testmat
diam_slide(testmat[["1"]])
diam_slide(testmat[[1]])
diam_slide(testmat[[1]])
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
return(diam)
}
diam_slide(testmat[[1]])
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R))])})
return(diam)
}
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R))])})
return(diam)
}
diam_slide(testmat[[1]])
seq(4,(16)-(4)))
seq(4,(16)-(4))
seq(4,16-(4-1)))
seq(4,16-(4-1))
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
testmat[[|]]
testmat[[1]]
diam_slide(testmat[[1]],R=1,D=2)
testmat[1:(1-(4-1)),1:(1+(4))]
testmat[[1]][1:(1-(4-1)),1:(1+(4))]
[1:(1-(4-1)),1:(1+(4))]
1:(1-(4-1)),1:(1+(4))]
1:(1-(4-1)),1:(1+(4))
c(1:(1+(4)))
c(1:(1-(4-1)))
c(2:(2-(4-1)))
c(3:(3-(4-1)))
c(4:(4-(4-1)))
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
print(diam)
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){print(d);
sum(M[d:(d-(D/R-1)),d:(d+(D/R))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){print(d);
sum(M[(d-(D/R-1)):d,d:(d+(D/R))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
testmat[[1]][1:(1-(4-1)),1:(1+(4))]
testmat[[1]][1:(4-(4-1)),4:(4+(4))]
testmat[[1]][4:(4-(4-1)),4:(4+(4))]
testmat[[1]][4:(4-(4-1)),4:(4+(4))]
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
c((4+1):(10-(4)))
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R+1):(length(M[1,])-(D/R))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
print(sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])}))
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R):(length(M[1,])-(D/R-1))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
diam_slide<-function(m,R=5000, D=100000){
M <- m
diam <- rep(0,length(M[1,])) # preallocating space for diamond-summed data.
diam[(D/R):(length(M[1,])-(D/R-1))] <- sapply(X = seq(D/R,(length(M[1,])-(D/R-1))),
simplify = T, FUN= function(d){print(d);
sum(M[d:(d-(D/R-1)),d:(d+(D/R-1))])})
return(diam)
}
diam_slide(testmat[[1]],R=1,D=4)
chrom="22"
setwd("/home/cyril/Documents/First_step/data/")
stopifnot(require(Matrix))
stopifnot(require(intervals))
#==========================
#Defining functions
index_2_pos <- function(ind, resolution=5000) { return(resolution * (ind - 1)) }# Finding actual position in genome from bin number.
pos_2_index <- function(pos, resolution=5000) { return(1 + (pos / resolution))  }  # Finding index in vector from entry in matrix
# m=contact matrix; R=resolution; L=vector containing length of genes;S=vector containing start of genes
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- floor(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
print(length(gTAD[,1]))
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("gene.start=",r,"; gene.end=", E[c],"; Matrix dimensions=",N))
print(paste0("gTADstart=", gTAD$start[1], ": gTAD$end=", gTAD$end[1]))
submat <- M[gTAD$start[1]:gTAD$end[1],gTAD$start[1]:gTAD$end[1]]
#print(submat)
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
if(length(gTAD[,1])>1){
print(paste("DOUBLE Overlap", gTAD, SEP=": "))
for(t in 2:length(gTAD$start)){
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
print(paste0("gTAD$start=", gTAD$start[t], ": gTAD$end=", gTAD$end[t]))
submat <- M[gTAD$start[t]:gTAD$end[t],gTAD$start[t]:gTAD$end[t]]
linc <- rbind(linc,linc[c,])
diam <-  append(diam,mean(submat))  # desired width of square (based on gene length)
}
}
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
# Loading all matrices in a list (takes pretty long)
linc_full <- read.table("linc_RNA/LCL.expressed.lincRNA.bed")  #your set of genes
colnames(linc_full)<-c("chr","start","end","gene","strand") #more convenient
TAD_full <- read.table("TAD/short/short_fullover_TAD.bed")
colnames(TAD_full)<-c("chr","start","end","ID") #more convenient
matlist <- list()
results <- data.frame()
for(c in c(chrom)){  # Loading matrices
tmp <- gzfile(paste0("norm_hic_data/GM12878/chr",c,"_5kb_norm.txt.gz"),"rt")  # Files are unzipped before read
matlist[[c]] <- c(readMM(tmp),c)
close(tmp)  # Freeing connection for next matrix
}
for(c in c(chrom)){  # Calling function and storing results for all chromosomes
TAD <- TAD_full[TAD_full$chr==paste0("chr",c),]
linc <- linc_full[linc_full$chr==paste0("chr",c),] #only on the same chromosome as your matrix
rownames(linc) <- NULL
if(length(linc$gene)>0){
tmp_results <- diam_slide(matlist[[c]], S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD)
print(tmp_results)
results <- rbind(results,tmp_results)
}
}
rownames(results) <- NULL
new <- results
stopifnot(require(Matrix))
stopifnot(require(intervals))
#==========================
#Defining functions
index_2_pos <- function(ind, resolution=5000) { return(resolution * (ind - 1)) }# Finding actual position in genome from bin number.
pos_2_index <- function(pos, resolution=5000) { return(1 + (pos / resolution))  }  # Finding index in vector from entry in matrix
# m=contact matrix; R=resolution; L=vector containing length of genes;S=vector containing start of genes
diam_slide<-function(m,R=5000,tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(tad[,1])) # preallocating space for diamond-summed data.
c <- 1
for(r in 1:length(tad$ID)){  # Iterating over TADs
start <- pos_2_index(tad$start[r],R)
end <- pos_2_index(tad$end[r],R)
print(paste0("r=",r,"; N=",N,"; start=",start,"; end=",end))
submat <- M[start:end,start:end]
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
# Storing normalized diamond sums in vector
if(c>30){break}
c <- c+1
}
return(cbind(tad,diam))
}
results <- data.frame()
for(c in c(chrom)){  # Calling function and storing results for all chromosomes
TAD <- TAD_full[TAD_full$chr==paste0("chr",c),]
#linc <- linc_full[linc_full$chr==paste0("chr",c),] #only on the same chromosome as your matrix
tmp_results <- diam_slide(matlist[[c]],tad=TAD)
print(tmp_results)
results <- rbind(results,tmp_results)
}
rownames(results) <- NULL
View(results)
View(new)
new[duplicated(new$gene),]
diam_slide<-function(m,R=5000,tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(tad[,1])) # preallocating space for diamond-summed data.
c <- 1
for(r in 1:length(tad$ID)){  # Iterating over TADs
start <- pos_2_index(tad$start[r],R)
end <- pos_2_index(tad$end[r],R)
print(paste0("r=",r,"; N=",N,"; start=",start,"; end=",end))
submat <- M[start:end,start:end]
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(tad,diam))
}
results <- data.frame()
for(c in c(chrom)){  # Calling function and storing results for all chromosomes
TAD <- TAD_full[TAD_full$chr==paste0("chr",c),]
#linc <- linc_full[linc_full$chr==paste0("chr",c),] #only on the same chromosome as your matrix
tmp_results <- diam_slide(matlist[[c]],tad=TAD)
print(tmp_results)
results <- rbind(results,tmp_results)
}
rownames(results) <- NULL
View(results)
22550840-22550000
22385000-22550000
setwd("/home/cyril/Documents/Master/sem_1/Data_analysis/reports/Arabidopsis/")
ara <- read.csv(file = "arabidopsis.csv")
setwd("/home/cyril/Documents/Master/sem_1/Data_analysis/reports/Arabidopsis/")
ara <- read.csv(file = "arabidopsis.csv")
View(ara)
library(c(lme4,car,MASS))
library(lme4);library(car),library(MASS)
library(lme4);library(car);library(MASS)
View(ara)
fitdistr(ara$total.fruits,"Poisson")
plot(fitdistr(ara$total.fruits,"Poisson"))
fitdistr(ara$total.fruits,densfun = "Poisson")
qqp(ara$total.fruits,"Poisson")
install.packages("fitdistrplus")
R
r
rversion()
rversion
poisson <- fitdistr(ara$total.fruits, "Poisson")
qqp(main="Poisson",ara$total.fruits, "pois", poisson$estimate)
setwd("/home/cyril/Documents/Internship/chalcid_comparative_analysis/Data/R_working_directory/manual/")
mydf <- read.csv("manual_processed_data.csv", header=T)
t
par(mfrow=c(2,2))
nbinom <- fitdistr(mydf$nbr_host_spp, "Negative Binomial")
qqp(main="Negative binomial",mydf$nbr_host_spp,
"nbinom", size = nbinom$estimate[[1]], mu = nbinom$estimate[[2]])
qqp(main="Lognormal", mydf$nbr_host_spp,"lnorm")
qqp(main="Normal", mydf$nbr_host_spp,"norm")
poisson <- fitdistr(mydf$nbr_host_spp[!is.na(mydf$nbr_host_spp)], "Poisson")
qqp(main="Poisson",mydf$nbr_host_spp, "pois", poisson$estimate)
setwd("/home/cyril/Documents/Internship/Data/R_working_directory/manual/")
mydf <- read.csv("manual_processed_data.csv", header=T)
mydf <- mydf[mydf$mode !="both" & !is.na(mydf$nbr_country) & mydf$nbr_country !=0 & mydf$pair!=0,]
#remove spp with sex + asex populations, with 0 countries, 0 hosts or not in a pair
mydf <-mydf[complete.cases(mydf[,1:4]),]
# Dropping all rows from which data was deleted (i.e. containing NA in all columns, taking the 4 first as reference)
max_dist_eq <- pmax(abs(mydf$lat_min),abs(mydf$lat_max))
mydf <- cbind(mydf,max_dist_eq)
#generating response variable
#------------------------------------------------------------------------------------------
# Comparing distance from equator against different distributions:
par(mfrow=c(2,2))
nbinom <- fitdistr(mydf$max_dist_eq[!is.na(mydf$max_dist_eq)], "Negative Binomial")
gamma <- fitdistr(mydf$max_dist_eq, "Gamma")
qqp(main="Gamma",mydf$max_dist_eq, "gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])
qqp(main="Lognormal", mydf$max_dist_eq,"lnorm")
qqp(main="Normal", mydf$max_dist_eq,"norm")
poisson <- fitdistr(mydf$max_dist_eq[!is.na(mydf$max_dist_eq)], "Poisson")
qqp(main="Poisson",mydf$max_dist_eq, "pois", poisson$estimate)
setwd("/home/cyril/Documents/Internship/chalcid_comparative_analysis/Data/R_working_directory/manual/")
mydf <- read.csv("manual_processed_data.csv", header=T)
mydf <- mydf[mydf$mode !="both" & mydf$nbr_country !=0 & mydf$pair!=0,]
#remove spp with sex + asex populations, with 0 countries, 0 hosts or not in a pair
mydf <-mydf[complete.cases(mydf[,1:4]),]
# Dropping all rows from which data was deleted (i.e. containing NA in all columns, taking the 4 first as reference)
# Comparing nbr of countries against different distributions:
par(mfrow=c(2,2))
gamma <- fitdistr(mydf$nbr_country, "gamma")
qqp(main="gamma",mydf$nbr_country,
"gamma", shape = gamma$estimate[[1]], rate = gamma$estimate[[2]])
qqp(main="Lognormal", mydf$nbr_country,"lnorm")
qqp(main="Normal", mydf$nbr_country,"norm")
poisson <- fitdistr(mydf$nbr_country[!is.na(mydf$nbr_country)], "Poisson")
qqp(main="Poisson",mydf$nbr_country, "pois", poisson$estimate)
#Fits best on lognorm, but count data -> poisson
qqp(main="Lognormal", ara$total.fruits,"lnorm")
ara$total.fruits
max(ara$total.fruits)
citation("Matrix")
citation("intervals")
poisson <- fitdistr(ara$total.fruits, "Poisson")
qqp(main="Poisson",ara$total.fruits, "pois", poisson$estimate)
setwd("/home/cyril/Documents/Master/sem_1/Data_analysis/reports/Arabidopsis/")
library(lme4);library(car);library(MASS);library(fits)
ara <- read.csv(file = "arabidopsis.csv")
poisson <- fitdistr(ara$total.fruits, "Poisson")
qqp(main="Poisson",ara$total.fruits, "pois", poisson$estimate)
setwd("/home/cyril/Documents/Master/sem_1/Data_analysis/reports/Arabidopsis/")
library(lme4);library(car);library(MASS);library(fits)
ara <- read.csv(file = "arabidopsis.csv")
poisson <- fitdistr(ara$total.fruits, "Poisson")
qqp(main="Poisson",ara$total.fruits, "pois", poisson$estimate)
